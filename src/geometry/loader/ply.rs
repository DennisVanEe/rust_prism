// This file contains the code for loading PLY files.
// This PLY file loader is NOT designed to be very "general", but it should perform alright.

use std::fs::File;
use std::io::{BufRead, BufReader};

use crate::geometry::mesh::{Mesh, Triangle};

/// Given a path, this function will load a mesh. If it can't load the 
/// mesh from the PLY file, it will indicate why.
pub fn load_path(path: &str) -> Result<Mesh> {
    let ply_file = File::open(path)?;
    let ply_file = BufReader::new(ply_file);

    // Process the header of the file:
    // Not the "cleanest" way of doing things, but it should be fast enough
    // and handle all cases I care to handle (and correctly error out for cases I 
    // don't care about). However, there are still cases where you can write really
    // bad PLY files, but most will be generated by a program, so this is not concerning.
    let mut is_binary = false;

    let mut reading_vertex_prop = false;
    let mut reading_face_prop = false;
    let mut read_vertex_prop = false;
    let mut read_face_prop = false;

    let mut num_vertices = 0usize;
    let mut num_faces = 0usize;

    // Properties that are supported for vertices:
    enum VertexProp { X, Y, Z, TX, TY, TZ, NX, NY, NZ, U, V }

    // Specifies the properties in the current file.
    let mut vertex_prop = Vec::new();

    for line in ply_file.lines() {
        let line = line?;
        // Check if we are done with the line:
        if line == "end_header" { break; }
        // Check if it's a comment, so we can ignore it:
        if line.starts_with("comment") { continue; }

        // Now for the actual meat of the problem:

        // If we are currently reading in properties, take note of them:
        if reading_vertex_prop {
            // Doubles are not supported at this point (I could cast them down, but right now I'm too lazy):
            if line.starts_with("property float") {
                let element_heading: Vec<&str> = line.split_whitespace().collect();
                if element_heading.len() != 3usize {
                    return Err("incorrectly formatted vertex element heading (missing number of elements)");
                } else {
                    match element_heading[2].as_ref() {
                        // position:
                        "x" => vertex_prop.push(VertexProp::X),
                        "y" => vertex_prop.push(VertexProp::Y),
                        "z" => vertex_prop.push(VertexProp::Z),
                        // tangents:
                        "tx" => vertex_prop.push(VertexProp::TX),
                        "ty" => vertex_prop.push(VertexProp::TY),
                        "tz" => vertex_prop.push(VertexProp::TZ),
                        // normals:
                        "nx" => vertex_prop.push(VertexProp::NX),
                        "ny" => vertex_prop.push(VertexProp::NY),
                        "nz" => vertex_prop.push(VertexProp::NZ),
                        // texture coord (can get messy with the multiple ways people do it):
                        "u" | "s" | "texture_u" | "texture_s" => vertex_prop.push(VertexProp::U),
                        "v" | "t" | "texture_v" | "texture_t" => vertex_prop.push(VertexProp::V),
                        _ => return Err("invalid property for vertices detected"),
                    }
                }
            } // maybe it's the start of another element
        } else if reading_face_prop {
            let property: Vec<&str> = line.split_whitespace().collect();
            if property.len() != 5usize {
                return Err("incorrectly formatted face property entry");
            } else {
                if !(property[0] == "property" && property[1] == "list" && property[4] == "vertex_indices" && (property[3] == "uint" || property[3] == "int")) {
                    return Err("invalid face list property detected");
                }
            }
            reading_face_prop = false; // There should be no other properties to read.
        }
        
        // Check if we are reading information about the vertex element:
        if line.starts_with("element vertex") && !read_vertex_prop {
            reading_face_prop = false;
            reading_vertex_prop = true;
            read_vertex_prop = true;
            // Record how many entries there are:
            let element_heading: Vec<&str> = line.split_whitespace().collect();
            if element_heading.len() != 3usize {
                return Err("incorrectly formatted vertex element heading (missing number of elements)");
            } else {
                num_vertices = element_heading[2].parse::<usize>()?;
            }
        // Check if we are reading information about the face element:
        } else if line.starts_with("element face") {
            reading_vertex_prop = false;
            reading_face_prop = true;
            read_face_prop = true;
            // Record how many entries there are:
            let element_heading: Vec<&str> = line.split_whitespace().collect();
            if element_heading.len() != 3usize {
                return Err("incorrectly formatted vertex element heading (missing number of elements)");
            } else {
                num_faces = element_heading[2].parse::<usize>()?;
            }
        } else {
            return Err("incorrectly formatted header detected or unsupported elements");
        }
    }

    if !read_face_prop || !read_vertex_prop {
        Err("could not read either vertices or faces");
    }

    // Now that we have all the information we want, hopefully, we may begin:
    // We can preallocate these as we know we must have some of these.
    let mut poss = Vec::with_capacity(num_vertices);
    let mut tris = Vec::with_capacity(num_faces);
    // These we can't preallocate:
    let mut norms = Vec::new();
    let mut tans = Vec::new();
    let mut uvs = Vec::new();

    if is_binary {

    } else {
        // We just read them line by line:
        
    }
}